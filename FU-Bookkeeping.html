<!doctype html>
<html lang="sv">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Mini-bokföring (BAS) – offline i webbläsaren</title>
  <style>
    :root{ --bg:#0b0f14; --card:#111826; --muted:#94a3b8; --text:#e5e7eb; --line:#223044; --ok:#22c55e; --bad:#ef4444; --accent:#60a5fa; }
    *{ box-sizing:border-box; }
    body{ margin:0; font-family: system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial; background:linear-gradient(180deg,#0b0f14,#070a0f); color:var(--text); }
    /* Header/nav: force-disable any lingering backdrop-filter (it can break clicks in some setups) */
    header{
      position:relative;
      z-index:5;
      background:rgba(11,15,20,.98);
      border-bottom:1px solid var(--line);
      backdrop-filter:none !important;
      -webkit-backdrop-filter:none !important;
      transform:none !important;
    }
    header::before{ content:none !important; }
    header .wrap, header nav{ position:relative; z-index:10; }
    header nav{ pointer-events:auto !important; }
    .tab{ pointer-events:auto !important; }

    /* Extra safety: ensure nothing overlays the nav row */
    header nav *{ pointer-events:auto !important; }

    .wrap{ max-width:1100px; margin:0 auto; padding:16px; }

    /* Layout with vertical navigation */
    .layout{ display:grid; grid-template-columns: 220px 1fr; gap:12px; align-items:start; }
    .sidebar{ display:grid; gap:8px; padding:12px; border:1px solid var(--line); border-radius:16px; background:rgba(17,24,38,.55); box-shadow: 0 10px 30px rgba(0,0,0,.18); }
    .sidebar .tab{ width:100%; text-align:left; }
    .content{ min-width:0; }

    @media (max-width: 900px){
      .layout{ grid-template-columns: 1fr; }
      .sidebar{ display:flex; flex-wrap:wrap; }
      .sidebar .tab{ width:auto; }
    }
    .row{ display:flex; gap:12px; align-items:center; flex-wrap:wrap; }
    h1{ margin:0; font-size:18px; font-weight:700; }
    .pill{ font-size:12px; color:var(--muted); border:1px solid var(--line); padding:6px 10px; border-radius:999px; }
    nav{ display:flex; gap:8px; margin-top:12px; flex-wrap:wrap; }
    button, input, select, textarea{ font:inherit; }
    .tab{ background:transparent; color:var(--muted); border:1px solid var(--line); padding:8px 12px; border-radius:10px; cursor:pointer; }
    .tab.active{ color:var(--text); border-color:rgba(96,165,250,.7); box-shadow:0 0 0 3px rgba(96,165,250,.12); }
    main .wrap{ padding-top:18px; }
    .grid{ display:grid; grid-template-columns: 1fr; gap:12px; }
    @media (min-width: 980px){ .grid.two{ grid-template-columns: 1fr 1fr; } }
    .card{ background:rgba(17,24,38,.75); border:1px solid var(--line); border-radius:16px; padding:14px; box-shadow: 0 10px 30px rgba(0,0,0,.25); }
    .card h2{ margin:0 0 10px 0; font-size:14px; color:var(--muted); font-weight:700; letter-spacing:.02em; }
    .muted{ color:var(--muted); }
    .btn{ background:rgba(96,165,250,.15); border:1px solid rgba(96,165,250,.4); color:var(--text); padding:8px 12px; border-radius:12px; cursor:pointer; }
    .btn.secondary{ background:transparent; border-color:var(--line); color:var(--text); }
    .btn.danger{ background:rgba(239,68,68,.12); border-color:rgba(239,68,68,.35); }
    .btn:disabled{ opacity:.5; cursor:not-allowed; }
    .field{ display:grid; gap:6px; }
    .field label{ font-size:12px; color:var(--muted); }
    input, select, textarea{ background:#0b1220; color:var(--text); border:1px solid var(--line); border-radius:12px; padding:10px 10px; outline:none; }
    input:focus, select:focus, textarea:focus{ border-color:rgba(96,165,250,.7); box-shadow:0 0 0 3px rgba(96,165,250,.12); }
    textarea{ min-height: 84px; resize: vertical; }
    table{ width:100%; border-collapse: collapse; }
    th, td{ border-bottom:1px solid rgba(34,48,68,.8); padding:8px 8px; text-align:left; vertical-align:top; }
    th{ font-size:12px; color:var(--muted); font-weight:700; }
    td{ font-size:13px; }
    .right{ text-align:right; }
    .status{ font-size:12px; padding:6px 10px; border-radius:999px; border:1px solid var(--line); }
    .status.ok{ color:var(--ok); border-color:rgba(34,197,94,.35); background:rgba(34,197,94,.08); }
    .status.bad{ color:var(--bad); border-color:rgba(239,68,68,.35); background:rgba(239,68,68,.08); }
    .list{ display:grid; gap:10px; }
    .item{ padding:10px; border:1px solid var(--line); border-radius:14px; background:rgba(11,18,32,.6); }
    .item .top{ display:flex; justify-content:space-between; gap:10px; flex-wrap:wrap; }
    .item .title{ font-weight:700; }
    .item .meta{ font-size:12px; color:var(--muted); }
    .kbd{ font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas; font-size:12px; color:var(--muted); }
    .small{ font-size:12px; }
  </style>
</head>
<body>
<header>
  <div class="wrap">
    <div class="row">
      <h1 id="companyName">Mini-bokföring</h1>
      <span class="pill" id="yearPill">Räkenskapsår: –</span>
      <span class="pill">Lagring: localStorage (offline)</span>
    </div>
  </div>
</header>

<main>
  <div class="wrap">
    <div class="layout">
      <aside class="sidebar" aria-label="Navigation" role="tablist">
        <button type="button" id="tabbtn-vouchers" class="tab active" data-tab="vouchers" role="tab" aria-controls="tab-vouchers" aria-selected="true">Verifikationer</button>
        <button type="button" id="tabbtn-accounts" class="tab" data-tab="accounts" role="tab" aria-controls="tab-accounts" aria-selected="false">Kontoplan</button>
        <button type="button" id="tabbtn-reports" class="tab" data-tab="reports" role="tab" aria-controls="tab-reports" aria-selected="false">Rapporter</button>
        <button type="button" id="tabbtn-export" class="tab" data-tab="export" role="tab" aria-controls="tab-export" aria-selected="false">Import/Export</button>
        <button type="button" id="tabbtn-settings" class="tab" data-tab="settings" role="tab" aria-controls="tab-settings" aria-selected="false">Inställningar</button>
      </aside>
      <div class="content">

    <!-- VERIFIKATIONER -->
    <section id="tab-vouchers" role="tabpanel" aria-labelledby="tabbtn-vouchers">
      <div class="grid two">
        <div class="card">
          <div class="row" style="justify-content:space-between; margin-bottom:10px;">
            <h2>Ny verifikation</h2>
            <div class="row">
              <button class="btn secondary" id="btnFillExample">Fyll A76–A79 (exempel)</button>
              <button class="btn" id="btnNewVoucher">Ny</button>
            </div>
          </div>

          <div class="grid" style="gap:10px;">
            <div class="row" style="gap:10px;">
              <div class="field" style="min-width:140px;">
                <label for="vDate">Datum</label>
                <input id="vDate" type="date" />
              </div>
              <div class="field" style="min-width:90px;">
                <label for="vSeries">Serie</label>
                <input id="vSeries" type="text" value="A" maxlength="10" />
              </div>
              <div class="field" style="min-width:110px;">
                <label for="vNo">Vernr</label>
                <input id="vNo" type="text" placeholder="Auto" />
              </div>
              <div class="field" style="min-width:160px; flex:1;">
                <label for="vText">Text</label>
                <input id="vText" type="text" placeholder="t.ex. Lagerjustering" />
              </div>
              <div class="field" style="min-width:140px;">
                <label for="vSign">Sign</label>
                <input id="vSign" type="text" placeholder="t.ex. MA" />
              </div>
            </div>

            <div class="card" style="padding:10px; border-radius:14px; background:rgba(11,18,32,.55);">
              <div class="row" style="justify-content:space-between; margin-bottom:8px;">
                <div class="muted small">Rader</div>
                <div class="row">
                  <span id="balanceBadge" class="status bad" role="status" aria-live="polite">Inte i balans</span>
                  <button class="btn secondary" id="btnAddLine">+ Rad</button>
                </div>
              </div>

              <div style="overflow:auto;">
                <table>
                  <thead>
                    <tr>
                      <th style="width:180px;">Konto</th>
                      <th>Radtext</th>
                      <th class="right" style="width:140px;">Debet</th>
                      <th class="right" style="width:140px;">Kredit</th>
                      <th style="width:70px;"></th>
                    </tr>
                  </thead>
                  <tbody id="linesTbody"></tbody>
                </table>
              </div>

              <div class="row" style="justify-content:space-between; margin-top:10px;">
                <div class="muted small">Tips: skriv 1460/1930 osv så filtreras listan.</div>
                <div class="row">
                  <button class="btn danger" id="btnClearVoucher">Rensa</button>
                  <button class="btn" id="btnSaveVoucher" disabled>Spara verifikation</button>
                </div>
              </div>
            </div>

            <div class="muted small">
              Balansregler: Summan debet ska vara lika med summan kredit. Programmet använder <span class="kbd">+ = debet</span> och <span class="kbd">− = kredit</span> internt.
            </div>
          </div>
        </div>

        <div class="card">
          <div class="row" style="justify-content:space-between; margin-bottom:10px;">
            <h2>Verifikationer i året</h2>
            <div class="row">
              <select id="yearSelect" aria-label="Räkenskapsår"></select>
              <button class="btn secondary" id="btnRefresh">Uppdatera</button>
            </div>
          </div>

          <div id="voucherList" class="list"></div>
        </div>
      </div>
    </section>

    <!-- KONTOPLAN -->
    <section id="tab-accounts" hidden role="tabpanel" aria-labelledby="tabbtn-accounts">
      <div class="grid two">
        <div class="card">
          <h2>Lägg till konto</h2>
          <div class="row" style="gap:10px;">
            <div class="field" style="min-width:140px;">
              <label for="aNo">Konto</label>
              <input id="aNo" placeholder="t.ex. 1930" />
            </div>
            <div class="field" style="flex:1; min-width:220px;">
              <label for="aName">Namn</label>
              <input id="aName" placeholder="t.ex. Företagskonto" />
            </div>
            <div class="field" style="min-width:180px;">
              <label for="aType">Typ (för rapporter)</label>
              <select id="aType">
                <option value="asset">Tillgång (klass 1)</option>
                <option value="liability">Eget kapital/skuld (klass 2)</option>
                <option value="income">Intäkt (klass 3)</option>
                <option value="expense">Kostnad (klass 4–8)</option>
                <option value="other">Övrigt</option>
              </select>
            </div>
            <button class="btn" id="btnAddAccount">Lägg till</button>
          </div>
          <p class="muted small" style="margin:10px 0 0 0;">Du kan lägga exakt de konton du vill (BAS). Appen kommer inte stoppa dig från att använda ett konto även om det är ”rubrik” – men rapporter blir bättre om du använder rätt underkonto (t.ex. 1460 i stället för 1400).</p>
        </div>

        <div class="card">
          <div class="row" style="justify-content:space-between; margin-bottom:10px;">
            <h2>Kontoplan</h2>
            <div class="row">
              <input id="accountSearch" placeholder="Sök (konto eller namn)" aria-label="Sök i kontoplan" />
              <button class="btn danger" id="btnResetDemo">Återställ demo-kontoplan</button>
            </div>
          </div>
          <div style="overflow:auto;">
            <table>
              <thead>
                <tr>
                  <th style="width:110px;">Konto</th>
                  <th>Namn</th>
                  <th style="width:170px;">Typ</th>
                  <th style="width:70px;"></th>
                </tr>
              </thead>
              <tbody id="accountsTbody"></tbody>
            </table>
          </div>
        </div>
      </div>
    </section>

    <!-- RAPPORTER -->
    <section id="tab-reports" hidden role="tabpanel" aria-labelledby="tabbtn-reports">
      <div class="grid two">
        <div class="card">
          <div class="row" style="justify-content:space-between;">
            <h2>Balans & Resultat (översikt)</h2>
            <select id="reportsYearSelect" aria-label="Räkenskapsår för rapporter"></select>
          </div>
          <div class="grid" style="gap:10px; margin-top:12px;">
            <div class="row" style="justify-content:space-between;">
              <div>
                <div class="muted small">Tillgångar</div>
                <div id="sumAssets" style="font-size:20px; font-weight:800;">–</div>
              </div>
              <div>
                <div class="muted small">EK + Skulder</div>
                <div id="sumEqLiab" style="font-size:20px; font-weight:800;">–</div>
              </div>
              <div>
                <div class="muted small">Årets resultat</div>
                <div id="sumResult" style="font-size:20px; font-weight:800;">–</div>
              </div>
            </div>
            <div class="muted small">Observera: detta är en förenklad rapport (bra för kontroll/avstämning, men inte en full årsredovisning).</div>
          </div>
        </div>

        <div class="card">
          <h2>Huvudbok / Saldolista</h2>
          <div class="row" style="gap:10px; margin-bottom:10px;">
            <select id="trialYearSelect" aria-label="Räkenskapsår för huvudbok/saldolista"></select>
            <button class="btn secondary" id="btnExportTrialCsv">Exportera CSV</button>
          </div>
          <div style="overflow:auto; max-height:520px;">
            <table>
              <thead>
                <tr>
                  <th style="width:110px;">Konto</th>
                  <th>Namn</th>
                  <th class="right" style="width:140px;">Saldo</th>
                </tr>
              </thead>
              <tbody id="trialTbody"></tbody>
            </table>
          </div>
        </div>
      </div>
    </section>

    <!-- EXPORT -->
    <section id="tab-export" hidden role="tabpanel" aria-labelledby="tabbtn-export">
      <div class="grid two">
        <div class="card">
          <h2>Backup (JSON)</h2>
          <div class="row" style="gap:10px; flex-wrap:wrap;">
            <button class="btn" id="btnExportJson">Ladda ner backup.json</button>
            <label class="btn secondary" style="display:inline-flex; align-items:center; gap:8px; cursor:pointer;">
              Importera JSON
              <input id="jsonImport" type="file" accept="application/json" hidden aria-label="Välj JSON-backup att importera" />
            </label>
            <button class="btn danger" id="btnWipe">Rensa ALL data</button>
          </div>
          <p class="muted small" style="margin-top:10px;">Tips: ta en backup innan du gör bokslutsverifikationer.</p>

          <div style="height:1px; background:rgba(34,48,68,.8); margin:12px 0;"></div>

          <h2>Fil-synk (Drive-mapp, valfritt)</h2>
          <div class="row" style="gap:10px; flex-wrap:wrap;">
            <button class="btn" id="btnConnectFile">Välj befintlig datafil</button>
            <button class="btn secondary" id="btnCreateFile">Skapa ny datafil</button>
            <button class="btn secondary" id="btnLoadFromFile" disabled>Läs in</button>
            <button class="btn secondary" id="btnSaveToFile" disabled>Spara nu</button>
            <button class="btn danger" id="btnDisconnectFile" disabled>Koppla från</button>
          </div>
          <div class="row" style="gap:10px; margin-top:10px; align-items:center;">
            <label class="muted small" style="display:flex; align-items:center; gap:8px;">
              <input id="fsAutosave" type="checkbox" /> Autospara till fil
            </label>
            <label class="muted small" style="display:flex; align-items:center; gap:8px;">
              <input id="fsRequireFile" type="checkbox" /> Kräv datafil (ingen bokföring utan fil)
            </label>
            <span id="fsStatus" class="status bad" role="status" aria-live="polite">Inte ansluten</span>
          </div>
          <p class="muted small" style="margin-top:10px;">
            Detta använder File System Access API (Chrome/Edge) och fungerar i <b>secure context</b> (HTTPS eller localhost). Välj en fil i en Google Drive-synkad mapp så syncas den av Drive for desktop.
          </p>
        </div>

        <div class="card">
          <h2>SIE-export (Typ 4)</h2>
          <div class="row" style="gap:10px;">
            <select id="sieYearSelect" aria-label="Räkenskapsår för SIE-export"></select>
            <button class="btn" id="btnExportSie4">Ladda ner SIE4</button>
          </div>
          <p class="muted small" style="margin-top:10px;">
            Exporten följer SIE 4B-principerna (#VER/#TRANS, samt #IB/#UB för balanskonto). Om mottagande program är super-strikt med teckenkodning (PC8/CP437) kan du behöva spara om filen via en editor som kan konvertera encoding.
          </p>

          <div style="height:1px; background:rgba(34,48,68,.8); margin:12px 0;"></div>

          <h2>SIE-import</h2>
          <div class="row" style="gap:10px; flex-wrap:wrap;">
            <select id="sieImportEncoding" title="Teckenkodning" aria-label="Teckenkodning för SIE-import">
              <option value="utf-8">UTF-8</option>
              <option value="windows-1252">Windows-1252</option>
              <option value="ibm437">IBM437 (PC8/CP437)</option>
            </select>
            <label class="btn secondary" style="display:inline-flex; align-items:center; gap:8px; cursor:pointer;">
              Välj SIE-fil
              <input id="sieImportFile" type="file" accept=".se,.sie,.txt,text/plain" hidden aria-label="Välj SIE-fil att importera" />
            </label>
            <button class="btn" id="btnImportSie">Importera</button>
            <label class="muted small" style="display:flex; align-items:center; gap:8px;">
              <input id="sieImportWipe" type="checkbox" /> Rensa innan import
            </label>
          </div>
          <p class="muted small" style="margin-top:10px;">
            Importen läser #KONTO, #RAR, #VER/#TRANS (objekt ignoreras). Tips: om importen blir konstig, testa att byta teckenkodning (många SIE är PC8/CP437).
          </p>
        </div>
      </div>
    </section>

    <!-- SETTINGS -->
    <section id="tab-settings" hidden role="tabpanel" aria-labelledby="tabbtn-settings">
      <div class="grid two">
        <div class="card">
          <h2>Företagsuppgifter</h2>
          <div class="grid" style="gap:10px;">
            <div class="field">
              <label for="sCompany">Företagsnamn</label>
              <input id="sCompany" placeholder="t.ex. Innovatio Brutalis AB" />
            </div>
            <div class="row" style="gap:10px;">
              <div class="field" style="flex:1; min-width:220px;">
                <label for="sOrgnr">Org.nr (för SIE)</label>
                <input id="sOrgnr" placeholder="t.ex. 559999-9999" />
              </div>
              <div class="field" style="min-width:170px;">
                <label for="sCurrency">Valuta</label>
                <select id="sCurrency">
                  <option>SEK</option>
                  <option>NOK</option>
                  <option>DKK</option>
                  <option>EUR</option>
                  <option>USD</option>
                </select>
              </div>
              <div class="field" style="min-width:140px;">
                <label for="sSign">Sign (default)</label>
                <input id="sSign" placeholder="t.ex. MA" />
              </div>
            </div>
            <div class="row" style="justify-content:flex-end;">
              <button class="btn" id="btnSaveSettings">Spara</button>
            </div>
          </div>
        </div>

        <div class="card">
          <h2>Räkenskapsår</h2>
          <div class="row" style="gap:10px; margin-bottom:10px;">
            <div class="field" style="min-width:160px;">
              <label for="fyStart">Start</label>
              <input id="fyStart" type="date" />
            </div>
            <div class="field" style="min-width:160px;">
              <label for="fyEnd">Slut</label>
              <input id="fyEnd" type="date" />
            </div>
            <button class="btn" id="btnAddYear">Lägg till år</button>
          </div>
          <div class="row" style="gap:10px; margin-bottom:10px;">
            <select id="carryFrom" aria-label="För över IB: från-år"></select>
            <select id="carryTo" aria-label="För över IB: till-år"></select>
            <button class="btn secondary" id="btnCarry">För över IB (balanskonto)</button>
          </div>
          <div class="muted small">För över IB skapar en verifikation på första dagen i ”Till”-året med text “Ingående balans”.</div>
          <div style="overflow:auto; margin-top:10px;">
            <table>
              <thead>
                <tr>
                  <th>År-id</th>
                  <th>Start</th>
                  <th>Slut</th>
                  <th style="width:70px;"></th>
                </tr>
              </thead>
              <tbody id="yearsTbody"></tbody>
            </table>
          </div>
        </div>
      </div>
    </section>
      </div>
    </div>
  </div>
</main>

<script>
(function(){
  const STORAGE_KEY = "mini_bokforing_v1";

  // --- Utilities ---
  const fmtSEK = (n) => {
    if (!Number.isFinite(n)) return "–";
    return n.toLocaleString("sv-SE", {minimumFractionDigits: 2, maximumFractionDigits: 2});
  };
  const parseMoney = (s) => {
    if (s == null) return 0;
    const t = String(s).trim().replace(/\s+/g, "").replace(/,/g, ".");
    if (t === "") return 0;
    const v = Number(t);
    return Number.isFinite(v) ? v : 0;
  };
  const ymd = (d) => d.replaceAll("-", "");
  const todayISO = () => {
    // Use local date (accounting-friendly). toISOString() uses UTC and can be off by one day.
    const now = new Date();
    const local = new Date(now.getTime() - now.getTimezoneOffset() * 60000);
    return local.toISOString().slice(0, 10);
  };
  const clampText = (s, max=120) => String(s ?? "").slice(0,max);

  // --- IndexedDB (för att lagra fil-handle mellan sessioner) ---
  const IDB_DB = "mini_bokforing_idb";
  const IDB_STORE = "kv";

  function idbOpen(){
    return new Promise((resolve, reject)=>{
      const req = indexedDB.open(IDB_DB, 1);
      req.onupgradeneeded = ()=>{
        const db = req.result;
        if (!db.objectStoreNames.contains(IDB_STORE)) db.createObjectStore(IDB_STORE);
      };
      req.onsuccess = ()=> resolve(req.result);
      req.onerror = ()=> reject(req.error);
    });
  }

  async function idbGet(key){
    const db = await idbOpen();
    return new Promise((resolve, reject)=>{
      const tx = db.transaction(IDB_STORE, "readonly");
      const st = tx.objectStore(IDB_STORE);
      const req = st.get(key);
      req.onsuccess = ()=> resolve(req.result);
      req.onerror = ()=> reject(req.error);
    });
  }

  async function idbSet(key, value){
    const db = await idbOpen();
    return new Promise((resolve, reject)=>{
      const tx = db.transaction(IDB_STORE, "readwrite");
      const st = tx.objectStore(IDB_STORE);
      const req = st.put(value, key);
      req.onsuccess = ()=> resolve(true);
      req.onerror = ()=> reject(req.error);
    });
  }

  async function idbDel(key){
    const db = await idbOpen();
    return new Promise((resolve, reject)=>{
      const tx = db.transaction(IDB_STORE, "readwrite");
      const st = tx.objectStore(IDB_STORE);
      const req = st.delete(key);
      req.onsuccess = ()=> resolve(true);
      req.onerror = ()=> reject(req.error);
    });
  }

  function defaultData(){
    const now = new Date();
    const y = now.getFullYear();
    return {
      company: { name: "Mini-bokföring", orgnr: "", currency: "SEK", defaultSign: "" },
      // File sync is optional. Default to localStorage-only so the app works on file://,
      // non-HTTPS contexts, and browsers without File System Access API.
      fileSync: { autosave: true, requireFile: false },
      fiscalYears: [
        { id: String(y-1), start: `${y-1}-01-01`, end: `${y-1}-12-31` },
        { id: String(y), start: `${y}-01-01`, end: `${y}-12-31` },
      ],
      activeYearId: String(y),
      accounts: demoAccounts(),
      vouchers: []
    };
  }

  function demoAccounts(){
    // Minimal BAS-ish set (du kan lägga fler i Kontoplan)
    return {
      "1630": { name: "Skattekonto", type: "asset" },
      "1930": { name: "Företagskonto/bank", type: "asset" },
      "1460": { name: "Varulager", type: "asset" },
      "2013": { name: "Eget uttag", type: "liability" },
      "2019": { name: "Årets resultat", type: "liability" },
      "4960": { name: "Förändring av lager", type: "expense" },
      "8999": { name: "Årets resultat (resultatkonto)", type: "other" }
    };
  }

  function load(){
    const raw = localStorage.getItem(STORAGE_KEY);
    if (!raw) return defaultData();
    try {
      const d = JSON.parse(raw);
      // very light migration defaults
      if (!d.company) d.company = defaultData().company;
      if (!d.fileSync) d.fileSync = { autosave: true, requireFile: false };
      if (typeof d.fileSync.requireFile !== "boolean") d.fileSync.requireFile = false;
      if (!d.fiscalYears) d.fiscalYears = defaultData().fiscalYears;
      if (!d.accounts) d.accounts = demoAccounts();
      if (!d.vouchers) d.vouchers = [];
      if (!d.activeYearId) d.activeYearId = d.fiscalYears[0]?.id ?? String(new Date().getFullYear());
      return d;
    } catch {
      return defaultData();
    }
  }
  function save(){
    try {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
      storageWriteFailed = false;
    } catch (e){
      // Quota exceeded / private mode can throw. Keep the UI functional but warn once.
      if (!storageWriteFailed){
        storageWriteFailed = true;
        alert("Kunde inte spara i localStorage (troligen fullt eller blockerat). Exportera JSON-backup för att inte tappa data.");
      }
    }
    renderAll();
    scheduleFileAutosave();
  }

  // --- Fil-synk (Drive-synkad mapp) ---
  function fsApiSupported(){
    return !!(window.showOpenFilePicker && window.showSaveFilePicker && window.isSecureContext);
  }

  function setFsStatus(kind, text){
    if (!fsStatus) return;
    fsStatus.className = "status " + (kind === "ok" ? "ok" : "bad");
    fsStatus.textContent = text;
  }

  function setEditingLocked(locked){
    // Lock core editing actions if user requires a file but none is connected.
    const ids = [
      "btnNewVoucher","btnAddLine","btnClearVoucher","btnSaveVoucher",
      "btnAddAccount","btnResetDemo",
      "btnAddYear","btnCarry",
      "btnWipe"
    ];
    ids.forEach(id => {
      const el = document.getElementById(id);
      if (el) el.disabled = !!locked;
    });

    // Also disable voucher editor fields to make it obvious
    const fields = ["vDate","vSeries","vNo","vText","vSign","aNo","aName","aType","fyStart","fyEnd"]; 
    fields.forEach(id => {
      const el = document.getElementById(id);
      if (el) el.disabled = !!locked;
    });

    // If locked, show a clear status
    if (locked){
      setFsStatus("bad", "Välj/Skapa datafil för att börja");
    }
  }

  function updateFsUI(){
    if (!fsStatus) return;

    // Autosave checkbox
    if (fsAutosave){
      fsAutosave.checked = !!(state.fileSync && state.fileSync.autosave);
      fsAutosave.disabled = !fsApiSupported();
    }

    if (fsRequireFile){
      fsRequireFile.checked = !!(state.fileSync && state.fileSync.requireFile);
      fsRequireFile.disabled = !fsApiSupported();
    }

    const connected = !!fsHandle;
    if (btnLoadFromFile) btnLoadFromFile.disabled = !connected;
    if (btnSaveToFile) btnSaveToFile.disabled = !connected;
    if (btnDisconnectFile) btnDisconnectFile.disabled = !connected;

    if (!fsApiSupported()){
      const requireFile = !!(state.fileSync && state.fileSync.requireFile);
      setFsStatus(
        "bad",
        requireFile
          ? "Fil-synk kräver HTTPS/localhost + Chrome/Edge (kör localStorage istället)"
          : "Fil-synk kräver HTTPS/localhost + Chrome/Edge"
      );
      // Even if the user previously enabled “require file”, fall back to localStorage when
      // the browser/context can’t support file handles; don’t dead-lock the whole app.
      setEditingLocked(false);
      return;
    }

    const requireFile = !!(state.fileSync && state.fileSync.requireFile);

    if (!connected){
      setFsStatus("bad", requireFile ? "Inte ansluten · kräver datafil" : "Inte ansluten");
      setEditingLocked(requireFile);
      return;
    }

    const name = fsHandle && fsHandle.name ? fsHandle.name : "(fil)";
    if (fsLastError){
      setFsStatus("bad", `${name} · fel`);
    } else if (fsLastSavedAt){
      setFsStatus("ok", `${name} · sparad ${fsLastSavedAt}`);
    } else {
      setFsStatus("ok", `${name} · ansluten`);
    }

    setEditingLocked(false);
  }

  async function fsEnsurePermission(request){
    if (!fsHandle) return false;
    const opts = { mode: "readwrite" };
    try {
      const q = await fsHandle.queryPermission(opts);
      if (q === "granted") return true;
      if (!request) return false;
      const r = await fsHandle.requestPermission(opts);
      return r === "granted";
    } catch (e){
      fsLastError = e;
      updateFsUI();
      return false;
    }
  }

  async function fsWriteState(){
    if (!fsHandle) throw new Error("Ingen fil ansluten");
    const ok = await fsEnsurePermission(false);
    if (!ok) throw new Error("Ingen behörighet (klicka 'Spara nu' för att tillåta)");

    const writable = await fsHandle.createWritable();
    await writable.write(JSON.stringify(state, null, 2));
    await writable.close();

    const now = new Date();
    fsLastSavedAt = now.toLocaleString("sv-SE", { hour12:false });
    fsLastError = null;
    updateFsUI();
  }

  async function fsLoadState(){
    if (!fsHandle) throw new Error("Ingen fil ansluten");
    const ok = await fsEnsurePermission(true);
    if (!ok) throw new Error("Behörighet nekad");

    const file = await fsHandle.getFile();
    const txt = await file.text();
    if (!txt.trim()) throw new Error("Filen är tom");

    const d = JSON.parse(txt);
    // minimal shape check
    if (!d || typeof d !== "object" || !Array.isArray(d.fiscalYears) || !d.accounts || !Array.isArray(d.vouchers)){
      throw new Error("Filen ser inte ut som en backup från appen");
    }

    state = d;
    // migration defaults
    if (!state.company) state.company = defaultData().company;
    if (!state.fileSync) state.fileSync = { autosave: true, requireFile: true };
    if (typeof state.fileSync.requireFile !== "boolean") state.fileSync.requireFile = true;
    save();
  }

  async function fsDisconnect(){
    fsHandle = null;
    fsLastError = null;
    fsLastSavedAt = null;
    await idbDel("dataFileHandle");
    updateFsUI();
  }

  async function fsConnectExisting(){
    if (!fsApiSupported()) return alert("Fil-synk kräver Chrome/Edge och secure context (HTTPS eller localhost)." );
    try {
      const picked = await window.showOpenFilePicker({
        multiple: false,
        types: [{ description: "Bokföringsdata (JSON)", accept: { "application/json": [".json"] } }]
      });
      const handle = picked && picked[0] ? picked[0] : null;
      if (!handle) return;

      fsHandle = handle;
      await idbSet("dataFileHandle", fsHandle);
      fsLastError = null;
      fsLastSavedAt = null;

      // Ask permission now (user just clicked), and auto-load if possible
      const ok = await fsEnsurePermission(true);
      if (ok){
        try { await fsLoadState(); }
        catch { /* file might be empty; ignore */ }
      }

      updateFsUI();
    } catch (e){
      if (e && e.name === "AbortError") return;
      fsLastError = e;
      updateFsUI();
      alert("Kunde inte välja fil. Är du på HTTPS/localhost och i Chrome/Edge?");
    }
  }

  async function fsCreateNew(){
    if (!fsApiSupported()) return alert("Fil-synk kräver Chrome/Edge och secure context (HTTPS eller localhost)." );
    try {
      const handle = await window.showSaveFilePicker({
        suggestedName: "bokforing.json",
        types: [{ description: "Bokföringsdata (JSON)", accept: { "application/json": [".json"] } }]
      });
      if (!handle) return;

      fsHandle = handle;
      await idbSet("dataFileHandle", fsHandle);
      fsLastError = null;
      fsLastSavedAt = null;
      updateFsUI();

      // Request permission and write initial content
      const ok = await fsEnsurePermission(true);
      if (ok){
        const writable = await fsHandle.createWritable();
        await writable.write(JSON.stringify(state, null, 2));
        await writable.close();
        const now = new Date();
        fsLastSavedAt = now.toLocaleString("sv-SE", { hour12:false });
        updateFsUI();
      }
    } catch (e){
      if (e && e.name === "AbortError") return;
      fsLastError = e;
      updateFsUI();
      alert("Kunde inte skapa fil. Är du på HTTPS/localhost och i Chrome/Edge?");
    }
  }

  function scheduleFileAutosave(){
    if (!fsApiSupported()) return;
    if (!fsHandle) return;
    if (!state.fileSync || !state.fileSync.autosave) return;

    if (fsAutosaveTimer) clearTimeout(fsAutosaveTimer);
    fsAutosaveTimer = setTimeout(async ()=>{
      try {
        // Only autosave if permission is already granted (no prompts without klick)
        const ok = await fsEnsurePermission(false);
        if (!ok) return;
        await fsWriteState();
      } catch (e){
        fsLastError = e;
        updateFsUI();
      }
    }, 600);
  }


  // --- State ---
  let state = load();
  let editingVoucherId = null;
  let storageWriteFailed = false;

  // File sync handle (stored in IndexedDB, not in state)
  let fsHandle = null;
  let fsLastSavedAt = null;
  let fsLastError = null;
  let fsAutosaveTimer = null;

  // --- DOM ---
  const tabs = Array.from(document.querySelectorAll(".tab"));
  const sections = {
    vouchers: document.getElementById("tab-vouchers"),
    accounts: document.getElementById("tab-accounts"),
    reports: document.getElementById("tab-reports"),
    export: document.getElementById("tab-export"),
    settings: document.getElementById("tab-settings"),
  };

  const companyNameEl = document.getElementById("companyName");
  const yearPillEl = document.getElementById("yearPill");

  const yearSelect = document.getElementById("yearSelect");
  const voucherList = document.getElementById("voucherList");

  const vDate = document.getElementById("vDate");
  const vSeries = document.getElementById("vSeries");
  const vNo = document.getElementById("vNo");
  const vText = document.getElementById("vText");
  const vSign = document.getElementById("vSign");
  const linesTbody = document.getElementById("linesTbody");
  const balanceBadge = document.getElementById("balanceBadge");
  const btnSaveVoucher = document.getElementById("btnSaveVoucher");

  const aNo = document.getElementById("aNo");
  const aName = document.getElementById("aName");
  const aType = document.getElementById("aType");
  const accountsTbody = document.getElementById("accountsTbody");
  const accountSearch = document.getElementById("accountSearch");

  const reportsYearSelect = document.getElementById("reportsYearSelect");
  const trialYearSelect = document.getElementById("trialYearSelect");
  const trialTbody = document.getElementById("trialTbody");
  const sumAssets = document.getElementById("sumAssets");
  const sumEqLiab = document.getElementById("sumEqLiab");
  const sumResult = document.getElementById("sumResult");

  const sieYearSelect = document.getElementById("sieYearSelect");

  // SIE import
  const sieImportFile = document.getElementById("sieImportFile");
  const btnImportSie = document.getElementById("btnImportSie");
  const sieImportEncoding = document.getElementById("sieImportEncoding");
  const sieImportWipe = document.getElementById("sieImportWipe");

  // File sync (Drive-synkad mapp via File System Access API)
  const btnConnectFile = document.getElementById("btnConnectFile");
  const btnCreateFile = document.getElementById("btnCreateFile");
  const btnLoadFromFile = document.getElementById("btnLoadFromFile");
  const btnSaveToFile = document.getElementById("btnSaveToFile");
  const btnDisconnectFile = document.getElementById("btnDisconnectFile");
  const fsAutosave = document.getElementById("fsAutosave");
  const fsRequireFile = document.getElementById("fsRequireFile");
  const fsStatus = document.getElementById("fsStatus");

  const sCompany = document.getElementById("sCompany");
  const sOrgnr = document.getElementById("sOrgnr");
  const sCurrency = document.getElementById("sCurrency");
  const sSign = document.getElementById("sSign");

  const fyStart = document.getElementById("fyStart");
  const fyEnd = document.getElementById("fyEnd");
  const yearsTbody = document.getElementById("yearsTbody");
  const carryFrom = document.getElementById("carryFrom");
  const carryTo = document.getElementById("carryTo");

  // --- Tab logic (robust: click + keyboard + capture) ---
  function activateTabByButton(btn){
    if (!btn) return;
    const t = btn.dataset ? btn.dataset.tab : null;
    if (!t) return;

    tabs.forEach(b => {
      b.classList.remove("active");
      b.setAttribute("aria-selected", "false");
    });
    btn.classList.add("active");
    btn.setAttribute("aria-selected", "true");

    Object.entries(sections).forEach(([k, el]) => {
      if (el) el.hidden = (k !== t);
    });

    if (t === "reports") renderReports();
    if (t === "settings") renderSettings();
    if (t === "accounts") renderAccounts();
  }

  // Direct handler
  tabs.forEach(btn => btn.addEventListener("click", (e) => {
    e.preventDefault();
    activateTabByButton(btn);
  }));

  // Capture handler (if something stops propagation)
  document.addEventListener("click", (e) => {
    const btn = e.target && e.target.closest ? e.target.closest(".tab") : null;
    if (!btn) return;
    e.preventDefault();
    activateTabByButton(btn);
  }, true);

  // Keyboard activation (Enter/Space) – some environments fail to synthesize click
  document.addEventListener("keydown", (e) => {
    if (e.key !== "Enter" && e.key !== " ") return;
    const el = document.activeElement;
    const btn = el && el.closest ? el.closest(".tab") : null;
    if (!btn) return;
    e.preventDefault();
    activateTabByButton(btn);
  }, true);

  // Focus activation (Tab navigation): switch view as soon as a tab receives focus
  document.addEventListener("focusin", (e) => {
    const btn = e.target && e.target.closest ? e.target.closest(".tab") : null;
    if (!btn) return;
    activateTabByButton(btn);
  }, true);

  // Pointer rescue: if an overlay intercepts clicks, pick the underlying .tab from elementsFromPoint
  document.addEventListener("pointerdown", (e) => {
    if (!document.elementsFromPoint) return;
    const els = document.elementsFromPoint(e.clientX, e.clientY);
    const btn = els && els.find ? els.find(x => x && x.classList && x.classList.contains("tab")) : null;
    if (!btn) return;
    e.preventDefault();
    e.stopPropagation();
    activateTabByButton(btn);
  }, true);

  // --- Accounts helpers ---
  function accountLabel(no){
    const a = state.accounts[no];
    return a ? `${no} – ${a.name}` : `${no} – (okänt konto)`;
  }

  function guessTypeFromAccountNo(no){
    const first = String(no)[0];
    if (first === "1") return "asset";
    if (first === "2") return "liability";
    if (first === "3") return "income";
    if (["4","5","6","7","8"].includes(first)) return "expense";
    return "other";
  }

  // --- Voucher editor ---
  let currentLines = [];

  function newVoucher(){
    editingVoucherId = null;
    vDate.value = todayISO();
    vSeries.value = "A";
    vNo.value = "";
    vText.value = "";
    vSign.value = state.company.defaultSign || "";
    currentLines = [ makeLine(), makeLine() ];
    renderLines();
    updateBalanceBadge();
    updateFsUI();
  }

  function makeLine(){
    // default first account to 1930 if exists
    const defaultAcc = state.accounts["1930"] ? "1930" : Object.keys(state.accounts)[0] || "";
    return { account: defaultAcc, text: "", debit: "", credit: "" };
  }

  function renderLines(){
    linesTbody.innerHTML = "";
    const accList = Object.keys(state.accounts).sort((a,b)=>a.localeCompare(b,"sv"));

    currentLines.forEach((ln, idx) => {
      const tr = document.createElement("tr");

      // account select
      const tdAcc = document.createElement("td");
      const sel = document.createElement("select");
      sel.style.width = "100%";
      sel.setAttribute("aria-label", `Konto (rad ${idx+1})`);
      accList.forEach(no => {
        const opt = document.createElement("option");
        opt.value = no;
        opt.textContent = accountLabel(no);
        sel.appendChild(opt);
      });
      if (!state.accounts[ln.account] && ln.account) {
        // allow unknown
        const opt = document.createElement("option");
        opt.value = ln.account;
        opt.textContent = accountLabel(ln.account);
        sel.insertBefore(opt, sel.firstChild);
      }
      sel.value = ln.account;
      sel.addEventListener("change", () => { ln.account = sel.value; updateBalanceBadge(); });
      tdAcc.appendChild(sel);

      // text
      const tdText = document.createElement("td");
      const inpText = document.createElement("input");
      inpText.value = ln.text;
      inpText.placeholder = "valfritt";
      inpText.setAttribute("aria-label", `Radtext (rad ${idx+1})`);
      inpText.addEventListener("input", () => ln.text = inpText.value);
      tdText.appendChild(inpText);

      // debit
      const tdD = document.createElement("td"); tdD.className = "right";
      const inpD = document.createElement("input");
      inpD.inputMode = "decimal";
      inpD.placeholder = "0";
      inpD.value = ln.debit;
      inpD.setAttribute("aria-label", `Debet (rad ${idx+1})`);
      inpD.addEventListener("input", () => {
        ln.debit = inpD.value;
        if (parseMoney(ln.debit) !== 0) ln.credit = "";
        renderLines();
        updateBalanceBadge();
      });
      tdD.appendChild(inpD);

      // credit
      const tdC = document.createElement("td"); tdC.className = "right";
      const inpC = document.createElement("input");
      inpC.inputMode = "decimal";
      inpC.placeholder = "0";
      inpC.value = ln.credit;
      inpC.setAttribute("aria-label", `Kredit (rad ${idx+1})`);
      inpC.addEventListener("input", () => {
        ln.credit = inpC.value;
        if (parseMoney(ln.credit) !== 0) ln.debit = "";
        renderLines();
        updateBalanceBadge();
      });
      tdC.appendChild(inpC);

      // delete
      const tdX = document.createElement("td");
      const bx = document.createElement("button");
      bx.className = "btn secondary";
      bx.textContent = "✕";
      bx.title = "Ta bort rad";
      bx.setAttribute("aria-label", `Ta bort rad ${idx+1}`);
      bx.addEventListener("click", () => {
        currentLines.splice(idx, 1);
        if (currentLines.length === 0) currentLines.push(makeLine());
        renderLines();
        updateBalanceBadge();
      });
      tdX.appendChild(bx);

      tr.appendChild(tdAcc);
      tr.appendChild(tdText);
      tr.appendChild(tdD);
      tr.appendChild(tdC);
      tr.appendChild(tdX);
      linesTbody.appendChild(tr);
    });
  }

  function voucherTotals(){
    const deb = currentLines.reduce((s,ln)=> s + Math.max(0, parseMoney(ln.debit)), 0);
    const cre = currentLines.reduce((s,ln)=> s + Math.max(0, parseMoney(ln.credit)), 0);
    return { deb, cre, diff: deb - cre };
  }

  function updateBalanceBadge(){
    const { deb, cre, diff } = voucherTotals();
    const ok = Math.abs(diff) < 0.00001 && deb > 0;
    balanceBadge.className = "status " + (ok ? "ok" : "bad");
    balanceBadge.textContent = ok ? `I balans (${fmtSEK(deb)})` : `Diff: ${fmtSEK(diff)}`;
    btnSaveVoucher.disabled = !ok;
  }

  function sanitizeVoucherLines(){
    // returns signed amounts: +debit, -credit
    return currentLines
      .map(ln => {
        const d = parseMoney(ln.debit);
        const c = parseMoney(ln.credit);
        const amount = d > 0 ? d : (c > 0 ? -c : 0);
        return {
          account: String(ln.account || "").trim(),
          text: clampText(ln.text || ""),
          amount: Math.round(amount * 100) / 100
        };
      })
      .filter(ln => ln.account && Math.abs(ln.amount) > 0.00001);
  }

  function getYear(id){ return state.fiscalYears.find(y => y.id === id); }

  function nextVerno(yearId, series){
    const seriesNorm = (series || "A").trim() || "A";
    const nums = state.vouchers
      .filter(v => v.yearId === yearId && (v.series || "") === seriesNorm)
      .map(v => Number(v.no))
      .filter(n => Number.isFinite(n));
    const max = nums.length ? Math.max(...nums) : 0;
    return String(max + 1);
  }

  function saveVoucher(){
    const yearId = yearSelect.value || state.activeYearId;
    const date = vDate.value || todayISO();
    const series = (vSeries.value || "A").trim() || "A";
    const no = (vNo.value || "").trim() || nextVerno(yearId, series);
    const text = clampText(vText.value || "");
    const sign = clampText((vSign.value || state.company.defaultSign || "").trim());
    const regDate = todayISO();
    const lines = sanitizeVoucherLines();

    // Validate balancing
    const sum = lines.reduce((s,l)=> s + l.amount, 0);
    if (Math.abs(sum) > 0.00001){
      alert("Verifikationen är inte i balans. Kontrollera debet/kredit.");
      return;
    }

    const v = {
      id: editingVoucherId ?? crypto.randomUUID(),
      yearId,
      series,
      no,
      date,
      text,
      regDate,
      sign,
      lines
    };

    const idx = state.vouchers.findIndex(x => x.id === v.id);
    if (idx >= 0) state.vouchers[idx] = v;
    else state.vouchers.push(v);

    // Keep list sorted for nicer export
    state.vouchers.sort((a,b)=> (a.yearId+b.series+a.no+a.date).localeCompare(b.yearId+a.series+b.no+b.date, "sv"));
    save();
    newVoucher();
  }

  function loadVoucherToEditor(id){
    const v = state.vouchers.find(x => x.id === id);
    if (!v) return;
    editingVoucherId = v.id;
    yearSelect.value = v.yearId;
    vDate.value = v.date;
    vSeries.value = v.series;
    vNo.value = v.no;
    vText.value = v.text;
    vSign.value = v.sign;

    currentLines = v.lines.map(l => ({
      account: l.account,
      text: l.text || "",
      debit: l.amount > 0 ? String(Math.abs(l.amount)).replace(".", ",") : "",
      credit: l.amount < 0 ? String(Math.abs(l.amount)).replace(".", ",") : ""
    }));
    if (currentLines.length === 0) currentLines = [makeLine(), makeLine()];
    renderLines();
    updateBalanceBadge();
  }

  function deleteVoucher(id){
    if (!confirm("Ta bort verifikationen?")) return;
    state.vouchers = state.vouchers.filter(v => v.id !== id);
    save();
  }

  // --- Calculations / Reports ---
  function yearVouchers(yearId){
    return state.vouchers.filter(v => v.yearId === yearId);
  }

  function accountBalances(yearId){
    const bal = {}; // account -> signed balance (debit positive)
    yearVouchers(yearId).forEach(v => {
      v.lines.forEach(l => {
        bal[l.account] = (bal[l.account] || 0) + l.amount;
      });
    });
    // round
    Object.keys(bal).forEach(k => bal[k] = Math.round(bal[k]*100)/100);
    return bal;
  }

  function splitBSIS(bal){
    let assets = 0;
    let eqLiab = 0;
    let income = 0;
    let expense = 0;

    for (const [acc, amt] of Object.entries(bal)){
      const t = (state.accounts[acc]?.type) || guessTypeFromAccountNo(acc);
      if (t === "asset") assets += amt;
      else if (t === "liability") eqLiab += amt;
      else if (t === "income") income += amt; // typically negative
      else if (t === "expense") expense += amt; // typically positive
      else {
        // if unknown, try by BAS class
        const gt = guessTypeFromAccountNo(acc);
        if (gt === "asset") assets += amt;
        else if (gt === "liability") eqLiab += amt;
        else if (gt === "income") income += amt;
        else if (gt === "expense") expense += amt;
      }
    }

    // result: income + expense (income negative) => negative profit; we present profit positive
    const resultSigned = income + expense;
    const profit = -resultSigned;

    return { assets, eqLiab, income, expense, profit };
  }

  function renderReports(){
    const yearId = reportsYearSelect.value || state.activeYearId;
    const bal = accountBalances(yearId);
    const { assets, eqLiab, profit } = splitBSIS(bal);

    sumAssets.textContent = fmtSEK(assets);
    sumEqLiab.textContent = fmtSEK(eqLiab);
    sumResult.textContent = fmtSEK(profit);

    // trial balance
    const yearId2 = trialYearSelect.value || yearId;
    const b2 = accountBalances(yearId2);
    const rows = Object.keys(state.accounts)
      .sort((a,b)=>a.localeCompare(b,"sv"))
      .map(acc => ({ acc, name: state.accounts[acc]?.name || "", amt: b2[acc] || 0 }))
      .filter(r => Math.abs(r.amt) > 0.00001);

    trialTbody.innerHTML = "";
    rows.forEach(r => {
      const tr = document.createElement("tr");
      tr.innerHTML = `
        <td>${escapeHtml(r.acc)}</td>
        <td>${escapeHtml(r.name)}</td>
        <td class="right">${fmtSEK(r.amt)}</td>
      `;
      trialTbody.appendChild(tr);
    });
  }

  // --- Render vouchers list ---
  function renderVoucherList(){
    const yearId = yearSelect.value || state.activeYearId;
    const list = yearVouchers(yearId)
      .slice()
      .sort((a,b)=> (a.series+a.no+a.date).localeCompare(b.series+b.no+b.date, "sv"));

    voucherList.innerHTML = "";
    if (list.length === 0){
      voucherList.innerHTML = `<div class="muted small">Inga verifikationer i detta räkenskapsår ännu.</div>`;
      return;
    }

    list.forEach(v => {
      const deb = v.lines.reduce((s,l)=> s + (l.amount>0?l.amount:0), 0);
      const cre = v.lines.reduce((s,l)=> s + (l.amount<0?-l.amount:0), 0);
      const div = document.createElement("div");
      div.className = "item";
      div.innerHTML = `
        <div class="top">
          <div>
            <div class="title">${escapeHtml(v.series)}${escapeHtml(v.no)} · ${escapeHtml(v.date)} · ${escapeHtml(v.text || "(utan text)")}</div>
            <div class="meta">${v.lines.length} rader · Debet ${fmtSEK(deb)} · Kredit ${fmtSEK(cre)} · Sign ${escapeHtml(v.sign||"-")}</div>
          </div>
          <div class="row">
            <button class="btn secondary" data-act="edit" data-id="${v.id}">Redigera</button>
            <button class="btn danger" data-act="del" data-id="${v.id}">Ta bort</button>
          </div>
        </div>
        <div style="margin-top:8px; overflow:auto;">
          <table>
            <thead>
              <tr>
                <th style="width:110px;">Konto</th>
                <th>Radtext</th>
                <th class="right" style="width:140px;">Belopp (debet + / kredit −)</th>
              </tr>
            </thead>
            <tbody>
              ${v.lines.map(l => `
                <tr>
                  <td>${escapeHtml(l.account)}</td>
                  <td>${escapeHtml(l.text || "")}</td>
                  <td class="right">${fmtSEK(l.amount)}</td>
                </tr>
              `).join("")}
            </tbody>
          </table>
        </div>
      `;
      div.addEventListener("click", (e)=>{
        const btn = e.target.closest("button");
        if (!btn) return;
        const id = btn.dataset.id;
        const act = btn.dataset.act;
        if (act === "edit") loadVoucherToEditor(id);
        if (act === "del") deleteVoucher(id);
      });
      voucherList.appendChild(div);
    });
  }

  // --- Accounts view ---
  function renderAccounts(){
    const q = (accountSearch.value || "").trim().toLowerCase();
    const keys = Object.keys(state.accounts).sort((a,b)=>a.localeCompare(b,"sv"));

    accountsTbody.innerHTML = "";
    keys.forEach(no => {
      const a = state.accounts[no];
      const hay = `${no} ${a.name} ${a.type}`.toLowerCase();
      if (q && !hay.includes(q)) return;
      const tr = document.createElement("tr");
      tr.innerHTML = `
        <td>${escapeHtml(no)}</td>
        <td>${escapeHtml(a.name)}</td>
        <td>${escapeHtml(typeLabel(a.type))}</td>
        <td><button class="btn danger" data-del="${no}">✕</button></td>
      `;
      tr.querySelector("button").addEventListener("click", ()=>{
        if (!confirm(`Ta bort konto ${no}? (verifikationer påverkas inte, men rapporter/export kan bli konstiga)`)) return;
        delete state.accounts[no];
        save();
      });
      accountsTbody.appendChild(tr);
    });
  }

  function typeLabel(t){
    return ({asset:"Tillgång", liability:"EK/Skuld", income:"Intäkt", expense:"Kostnad", other:"Övrigt"})[t] || "Övrigt";
  }

  // --- Settings ---
  function renderSettings(){
    sCompany.value = state.company.name || "";
    sOrgnr.value = state.company.orgnr || "";
    sCurrency.value = state.company.currency || "SEK";
    sSign.value = state.company.defaultSign || "";

    yearsTbody.innerHTML = "";
    state.fiscalYears.forEach(y => {
      const tr = document.createElement("tr");
      tr.innerHTML = `
        <td>${escapeHtml(y.id)}</td>
        <td>${escapeHtml(y.start)}</td>
        <td>${escapeHtml(y.end)}</td>
        <td><button class="btn danger" data-y="${y.id}">✕</button></td>
      `;
      tr.querySelector("button").addEventListener("click", ()=>{
        if (!confirm(`Ta bort räkenskapsår ${y.id}? (verifikationer i året raderas INTE automatiskt)`)) return;
        state.fiscalYears = state.fiscalYears.filter(z => z.id !== y.id);
        if (!state.fiscalYears.find(z => z.id === state.activeYearId)){
          state.activeYearId = state.fiscalYears[0]?.id || "";
        }
        save();
      });
      yearsTbody.appendChild(tr);
    });

    fillYearSelectors();
  }

  function fillYearSelectors(){
    const ys = state.fiscalYears.slice().sort((a,b)=>a.id.localeCompare(b.id,"sv"));

    const selects = [yearSelect, reportsYearSelect, trialYearSelect, sieYearSelect, carryFrom, carryTo];
    selects.forEach(sel => {
      const prev = sel.value;
      sel.innerHTML = "";
      ys.forEach(y => {
        const opt = document.createElement("option");
        opt.value = y.id;
        opt.textContent = `${y.id} (${y.start} – ${y.end})`;
        sel.appendChild(opt);
      });
      sel.value = ys.find(y=>y.id===prev)?.id || state.activeYearId || ys[0]?.id || "";
    });

    companyNameEl.textContent = state.company.name || "Mini-bokföring";
    const y = getYear(state.activeYearId);
    yearPillEl.textContent = y ? `Räkenskapsår: ${y.id} (${y.start} – ${y.end})` : `Räkenskapsår: ${state.activeYearId}`;
  }

  // --- Carry forward IB ---
  function carryForwardIB(fromId, toId){
    if (fromId === toId) return alert("Välj två olika år.");
    const fromYear = getYear(fromId);
    const toYear = getYear(toId);
    if (!fromYear || !toYear) return;

    const bal = accountBalances(fromId);

    // Keep only balance sheet-ish: account class 1 & 2, plus user-typed asset/liability
    const ibLines = Object.entries(bal)
      .filter(([acc, amt]) => {
        const t = state.accounts[acc]?.type || guessTypeFromAccountNo(acc);
        if (t === "asset" || t === "liability") return Math.abs(amt) > 0.00001;
        const first = String(acc)[0];
        return (first === "1" || first === "2") && Math.abs(amt) > 0.00001;
      })
      .map(([acc, amt]) => ({ account: acc, text: "IB", amount: Math.round(amt*100)/100 }));

    // Create a voucher on toYear start with these lines, plus a balancing line if needed
    const sum = ibLines.reduce((s,l)=> s + l.amount, 0);
    if (Math.abs(sum) > 0.00001){
      // In theory assets+liab should balance already; if not, put difference on 2019 (or create it)
      if (!state.accounts["2019"]) state.accounts["2019"] = { name: "Årets resultat", type: "liability" };
      ibLines.push({ account: "2019", text: "IB justering", amount: -Math.round(sum*100)/100 });
    }

    const series = "IB";
    const no = nextVerno(toId, series);
    state.vouchers.push({
      id: crypto.randomUUID(),
      yearId: toId,
      series,
      no,
      date: toYear.start,
      text: "Ingående balans",
      regDate: todayISO(),
      sign: state.company.defaultSign || "",
      lines: ibLines
    });

    save();
    alert(`Skapade IB-verifikation i ${toId} (${toYear.start}).`);
  }

  // --- Export helpers (download) ---
  function downloadText(filename, text, mime="text/plain"){
    const blob = new Blob([text], {type: mime});
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(()=> URL.revokeObjectURL(a.href), 1500);
  }

  function escapeHtml(s){
    return String(s ?? "").replace(/[&<>\"']/g, c => ({"&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#39;"}[c]));
  }

  // --- SIE4 Export (simplified but compliant-ish) ---
  function sieQuote(s){
    // SIE spec: use ASCII 34 quotes for fields with spaces; escape quotes with backslash
    const t = String(s ?? "");
    const esc = t.replaceAll("\\", "\\\\").replaceAll('"', '\\"');
    return `"${esc}"`;
  }

  function toSieAmount(n){
    // dot decimals, max 2, no plus sign
    const v = Math.round((Number(n) || 0) * 100) / 100;
    // Avoid trailing .00 if integer? Spec allows without decimals; we keep 2 decimals for stability.
    return v.toFixed(2);
  }

  function exportSIE4(yearId){
    const fy = getYear(yearId);
    if (!fy) return alert("Okänt räkenskapsår.");

    // balances for IB/UB
    const bal = accountBalances(yearId);

    const lines = [];
    lines.push("#FLAGGA 0");
    lines.push(`#PROGRAM ${sieQuote("Mini-bokföring (HTML)")} ${sieQuote("1.0")}`);
    lines.push("#FORMAT PC8");
    lines.push(`#GEN ${ymd(todayISO())} ${sieQuote(state.company.defaultSign || "")}`);
    lines.push(`#FNAMN ${sieQuote(state.company.name || "")}`);
    if (state.company.orgnr) lines.push(`#ORGNR ${sieQuote(state.company.orgnr)}`);
    if (state.company.currency && state.company.currency !== "SEK") lines.push(`#VALUTA ${sieQuote(state.company.currency)}`);
    lines.push("#KPTYP EUBAS97");
    lines.push(`#SIETYP 4`);
    lines.push(`#RAR 0 ${ymd(fy.start)} ${ymd(fy.end)}`);

    // chart of accounts
    Object.keys(state.accounts)
      .sort((a,b)=>a.localeCompare(b,"sv"))
      .forEach(acc => {
        lines.push(`#KONTO ${acc} ${sieQuote(state.accounts[acc].name || "")}`);
      });

    // IB (only for balance sheet accounts)
    Object.entries(bal)
      .filter(([acc, amt]) => {
        const t = state.accounts[acc]?.type || guessTypeFromAccountNo(acc);
        if (t === "asset" || t === "liability") return true;
        const first = String(acc)[0];
        return first === "1" || first === "2";
      })
      .sort(([a],[b])=>a.localeCompare(b,"sv"))
      .forEach(([acc, amt]) => {
        // For simplicity we set #IB equal to current-year balance if you only book IB in year.
        // If you have a full year of transactions, IB should ideally be start balances.
        // Use the Carry-forward feature to create correct IB voucher.
        lines.push(`#IB 0 ${acc} ${toSieAmount(amt)}`);
      });

    // verifications
    const vs = yearVouchers(yearId)
      .slice()
      .sort((a,b)=> (a.series+a.no+a.date).localeCompare(b.series+b.no+b.date, "sv"));

    vs.forEach(v => {
      lines.push(`#VER ${sieQuote(v.series)} ${sieQuote(v.no)} ${ymd(v.date)} ${sieQuote(v.text || "")} ${ymd(v.regDate || v.date)} ${sieQuote(v.sign || "")}`);
      lines.push("{");
      v.lines.forEach(l => {
        lines.push(` #TRANS ${l.account} { } ${toSieAmount(l.amount)} ${ymd(v.date)} ${sieQuote(l.text || v.text || "")}`);
      });
      lines.push("}");
    });

    // UB (closing) for balance sheet accounts, year 0 should always be present
    Object.entries(bal)
      .filter(([acc, amt]) => {
        const t = state.accounts[acc]?.type || guessTypeFromAccountNo(acc);
        if (t === "asset" || t === "liability") return true;
        const first = String(acc)[0];
        return first === "1" || first === "2";
      })
      .sort(([a],[b])=>a.localeCompare(b,"sv"))
      .forEach(([acc, amt]) => {
        lines.push(`#UB 0 ${acc} ${toSieAmount(amt)}`);
      });

    const content = lines.join("\n") + "\n";
    downloadText(`SIE4_${yearId}.se`, content, "text/plain");
  }

  // --- SIE import (basic) ---
  function isAllDigits(s){
    for (let i=0;i<s.length;i++){
      const c = s.charCodeAt(i);
      if (c < 48 || c > 57) return false;
    }
    return s.length > 0;
  }

  function parseSieDate(s){
    const t = String(s || "").trim();
    if (t.length === 8 && isAllDigits(t)) return t.slice(0,4) + "-" + t.slice(4,6) + "-" + t.slice(6,8);
    if (t.length === 10 && t[4] === "-" && t[7] === "-") return t;
    return t;
  }

  function parseSieAmount(s){
    const t = String(s || "").trim().replace(",", ".");
    const v = Number(t);
    return Number.isFinite(v) ? Math.round(v * 100) / 100 : 0;
  }

  function tokenizeSieLine(line){
    const tokens = [];
    const BS = String.fromCharCode(92); // backslash
    let i = 0;
    while (i < line.length){
      while (i < line.length && line.charCodeAt(i) <= 32) i++;
      if (i >= line.length) break;
      if (line[i] === '"'){
        i++;
        let out = "";
        while (i < line.length){
          const ch = line[i];
          if (ch === BS && i+1 < line.length){ out += line[i+1]; i += 2; continue; }
          if (ch === '"'){ i++; break; }
          out += ch;
          i++;
        }
        tokens.push(out);
      } else {
        let j = i;
        while (j < line.length && line.charCodeAt(j) > 32) j++;
        tokens.push(line.slice(i, j));
        i = j;
      }
    }
    return tokens;
  }

  async function readFileAsText(file, encoding){
    const buf = await file.arrayBuffer();
    const enc = (encoding || "utf-8").toLowerCase();
    try { return new TextDecoder(enc, {fatal:false}).decode(buf); }
    catch { return new TextDecoder("utf-8", {fatal:false}).decode(buf); }
  }

  function normalizeNewlines(text){
    const CR = String.fromCharCode(13);
    const LF = String.fromCharCode(10);
    return String(text || "").split(CR + LF).join(LF).split(CR).join(LF);
  }

  function ensureYearExists(id){
    if (!id) return;
    if (!state.fiscalYears.find(y => y.id === id)){
      state.fiscalYears.push({ id, start: id + "-01-01", end: id + "-12-31" });
      state.fiscalYears.sort((a,b)=>a.id.localeCompare(b.id, "sv"));
    }
  }

  function yearIdForDate(dateIso){
    const d = dateIso;
    for (const fy of state.fiscalYears){
      if (fy.start <= d && d <= fy.end) return fy.id;
    }
    return d ? d.slice(0,4) : state.activeYearId;
  }

  function parseSIE(text){
    const parsed = { company:{}, fiscalYears:[], accounts:{}, vouchers:[] };
    const rarByNo = {}; // "0" -> {id,start,end}

    let currentVoucher = null;
    let currentYearIdHint = null;

    const lines = normalizeNewlines(text).split(String.fromCharCode(10));

    for (const raw of lines){
      const line = String(raw || "").trim();
      if (!line) continue;
      if (line[0] === ";") continue;

      if (line.startsWith("#FNAMN")){
        const t = tokenizeSieLine(line);
        if (t[1]) parsed.company.name = t[1];
        continue;
      }
      if (line.startsWith("#ORGNR")){
        const t = tokenizeSieLine(line);
        if (t[1]) parsed.company.orgnr = t[1];
        continue;
      }
      if (line.startsWith("#VALUTA")){
        const t = tokenizeSieLine(line);
        if (t[1]) parsed.company.currency = t[1];
        continue;
      }
      if (line.startsWith("#KONTO")){
        const t = tokenizeSieLine(line);
        const acc = t[1];
        const name = t.slice(2).join(" ").trim();
        if (acc) parsed.accounts[acc] = { name: name || ("(konto " + acc + ")"), type: guessTypeFromAccountNo(acc) };
        continue;
      }
      if (line.startsWith("#RAR")){
        const t = tokenizeSieLine(line);
        const rarNo = String(t[1] ?? "");
        const start = parseSieDate(t[2]);
        const end = parseSieDate(t[3]);
        if (rarNo && start && end){
          const id = start.slice(0,4);
          rarByNo[rarNo] = { id, start, end };
          if (!parsed.fiscalYears.find(y => y.id === id)) parsed.fiscalYears.push({ id, start, end });
          if (rarNo === "0") currentYearIdHint = id;
        }
        continue;
      }

      if (line === "{") continue;

      if (line === "}"){
        if (currentVoucher){
          // Validate balance before keeping
          const sum = currentVoucher.lines.reduce((s,l)=> s + l.amount, 0);
          if (Math.abs(sum) < 0.01) parsed.vouchers.push(currentVoucher);
          currentVoucher = null;
        }
        continue;
      }

      if (line.startsWith("#VER")){
        const t = tokenizeSieLine(line);
        const series = String(t[1] ?? "A");
        const no = String(t[2] ?? "");
        const date = parseSieDate(t[3]);
        const textV = String(t[4] ?? "");
        const regDate = parseSieDate(t[5] ?? date);
        const sign = String(t[6] ?? "");

        const yearId = currentYearIdHint || (date ? date.slice(0,4) : "");
        currentVoucher = {
          id: crypto.randomUUID(),
          yearId,
          series,
          no,
          date,
          text: textV,
          regDate,
          sign,
          lines: []
        };
        continue;
      }

      if (line.startsWith("#TRANS") && currentVoucher){
        const t = tokenizeSieLine(line);
        const acc = t[1];
        if (!acc) continue;

        let idx = 2;
        // Skip object list token(s) { ... }
        if (t[idx] && (t[idx] === "{" || String(t[idx]).startsWith("{"))){
          while (idx < t.length && !(t[idx] === "}" || String(t[idx]).endsWith("}"))) idx++;
          idx++;
        }
        const amount = parseSieAmount(t[idx]); idx++;
        // date exists in SIE, but we keep voucher date as primary
        const _dt = parseSieDate(t[idx]); idx++;
        const txt = t.slice(idx).join(" ");

        currentVoucher.lines.push({
          account: String(acc),
          text: txt || currentVoucher.text || "",
          amount: Math.round(amount * 100) / 100
        });

        if (!parsed.accounts[String(acc)]){
          parsed.accounts[String(acc)] = { name: "(konto " + acc + ")", type: guessTypeFromAccountNo(acc) };
        }
        continue;
      }
    }

    parsed.fiscalYears.sort((a,b)=>a.id.localeCompare(b.id, "sv"));

    // Fallback: if file had no #RAR, derive years from vouchers
    if (parsed.fiscalYears.length === 0 && parsed.vouchers.length){
      const set = new Set();
      for (const v of parsed.vouchers){
        if (v.date && v.date.length >= 4) set.add(v.date.slice(0,4));
      }
      for (const id of set){
        parsed.fiscalYears.push({ id, start: id + "-01-01", end: id + "-12-31" });
      }
      parsed.fiscalYears.sort((a,b)=>a.id.localeCompare(b.id, "sv"));
    }

    // If yearId on vouchers looks empty, set it based on date
    for (const v of parsed.vouchers){
      if (!v.yearId) v.yearId = v.date ? v.date.slice(0,4) : "";
    }

    return parsed;
  }

  function mergeParsedSIE(parsed, wipe){
    const before = { years: state.fiscalYears.length, accounts: Object.keys(state.accounts).length, vouchers: state.vouchers.length };

    if (wipe){
      state = defaultData();
      state.accounts = {};
      state.vouchers = [];
      state.fiscalYears = [];
    }

    // Company
    if (parsed.company?.name && (!state.company.name || state.company.name === "Mini-bokföring")) state.company.name = parsed.company.name;
    if (parsed.company?.orgnr && !state.company.orgnr) state.company.orgnr = parsed.company.orgnr;
    if (parsed.company?.currency) state.company.currency = parsed.company.currency;

    // Years
    for (const y of (parsed.fiscalYears || [])){
      if (!state.fiscalYears.find(z => z.id === y.id)) state.fiscalYears.push({ id:y.id, start:y.start, end:y.end });
    }
    state.fiscalYears.sort((a,b)=>a.id.localeCompare(b.id, "sv"));

    // Accounts
    for (const [acc, a] of Object.entries(parsed.accounts || {})){
      if (!state.accounts[acc]) state.accounts[acc] = a;
      else {
        if (String(state.accounts[acc].name || "").startsWith("(konto") && a.name) state.accounts[acc].name = a.name;
        if (!state.accounts[acc].type && a.type) state.accounts[acc].type = a.type;
      }
    }

    // Vouchers (skip duplicates)
    const existing = new Set(state.vouchers.map(v => String(v.yearId) + "|" + String(v.series) + "|" + String(v.no) + "|" + String(v.date)));
    for (const v of (parsed.vouchers || [])){
      const yearId = v.yearId || yearIdForDate(v.date);
      v.yearId = yearId;
      ensureYearExists(yearId);

      const key = String(v.yearId) + "|" + String(v.series) + "|" + String(v.no) + "|" + String(v.date);
      if (existing.has(key)) continue;
      state.vouchers.push(v);
      existing.add(key);
    }

    // Active year: latest
    const latest = state.fiscalYears.slice().sort((a,b)=>a.id.localeCompare(b.id, "sv")).at(-1);
    if (latest) state.activeYearId = latest.id;

    // sort vouchers
    state.vouchers.sort((a,b)=> (a.yearId+b.series+a.no+a.date).localeCompare(b.yearId+b.series+b.no+b.date, "sv"));

    save();

    const after = { years: state.fiscalYears.length, accounts: Object.keys(state.accounts).length, vouchers: state.vouchers.length };
    return { before, after };
  }

  // --- CSV trial balance export ---
  function exportTrialCsv(yearId){
    const b = accountBalances(yearId);
    const rows = Object.keys(state.accounts)
      .sort((a,b)=>a.localeCompare(b,"sv"))
      .map(acc => [acc, state.accounts[acc]?.name || "", (b[acc]||0).toFixed(2)])
      .filter(r => Math.abs(Number(r[2])) > 0.00001);

    const csv = ["Konto;Namn;Saldo"].concat(rows.map(r => r.map(x=>String(x).replaceAll(";", ",")).join(";"))).join("\n") + "\n";
    downloadText(`saldolista_${yearId}.csv`, csv, "text/csv");
  }

  // --- Event wiring ---
  document.getElementById("btnNewVoucher").addEventListener("click", newVoucher);
  document.getElementById("btnAddLine").addEventListener("click", ()=>{ currentLines.push(makeLine()); renderLines(); updateBalanceBadge(); });
  document.getElementById("btnClearVoucher").addEventListener("click", ()=>{ if (!confirm("Rensa verifikationen?")) return; newVoucher(); });
  document.getElementById("btnSaveVoucher").addEventListener("click", saveVoucher);
  document.getElementById("btnRefresh").addEventListener("click", renderAll);
  yearSelect.addEventListener("change", ()=>{ state.activeYearId = yearSelect.value; save(); });

  document.getElementById("btnAddAccount").addEventListener("click", ()=>{
    const no = String(aNo.value||"").trim();
    const name = String(aName.value||"").trim();
    const type = aType.value;
    if (!/^\d{4}$/.test(no)) return alert("Kontonummer ska vara 4 siffror (t.ex. 1930).");
    if (!name) return alert("Ange kontonamn.");
    state.accounts[no] = { name, type };
    aNo.value = ""; aName.value = "";
    save();
  });
  accountSearch.addEventListener("input", renderAccounts);

  document.getElementById("btnResetDemo").addEventListener("click", ()=>{
    if (!confirm("Återställ kontoplanen till demo? (Detta skriver över dina konton.)")) return;
    state.accounts = demoAccounts();
    save();
  });

  document.getElementById("btnExportJson").addEventListener("click", ()=>{
    downloadText("backup.json", JSON.stringify(state, null, 2), "application/json");
  });

  document.getElementById("jsonImport").addEventListener("change", async (e)=>{
    const file = e.target.files?.[0];
    if (!file) return;
    const txt = await file.text();
    try {
      const d = JSON.parse(txt);
      // Minimal validation + migration defaults (same intent as fsLoadState)
      if (!d || typeof d !== "object" || !Array.isArray(d.fiscalYears) || !d.accounts || !Array.isArray(d.vouchers)){
        throw new Error("Invalid backup shape");
      }
      state = d;
      if (!state.company) state.company = defaultData().company;
      if (!state.fileSync) state.fileSync = { autosave: true, requireFile: false };
      if (typeof state.fileSync.requireFile !== "boolean") state.fileSync.requireFile = false;
      if (!state.activeYearId) state.activeYearId = state.fiscalYears[0]?.id ?? String(new Date().getFullYear());
      save();
      updateFsUI();
      alert("Import klar.");
    } catch {
      alert("Kunde inte läsa JSON.");
    }
    e.target.value = "";
  });

  document.getElementById("btnWipe").addEventListener("click", ()=>{
    if (!confirm("Rensa ALL data? Detta går inte att ångra.")) return;
    localStorage.removeItem(STORAGE_KEY);
    state = defaultData();
    save();
    newVoucher();
  });

  // File sync actions
  if (btnConnectFile) btnConnectFile.addEventListener("click", fsConnectExisting);
  if (btnCreateFile) btnCreateFile.addEventListener("click", fsCreateNew);

  if (btnSaveToFile) btnSaveToFile.addEventListener("click", async ()=>{
    try {
      if (!fsHandle) return;
      const ok = await fsEnsurePermission(true);
      if (!ok) return alert("Behörighet nekad.");
      await fsWriteState();
    } catch (e){
      fsLastError = e;
      updateFsUI();
      alert("Kunde inte spara till fil.");
    }
  });

  if (btnLoadFromFile) btnLoadFromFile.addEventListener("click", async ()=>{
    try {
      if (!fsHandle) return;
      if (!confirm("Läsa in data från filen och ersätta det som finns i appen nu?") ) return;
      await fsLoadState();
    } catch (e){
      fsLastError = e;
      updateFsUI();
      alert("Kunde inte läsa in filen.");
    }
  });

  if (btnDisconnectFile) btnDisconnectFile.addEventListener("click", async ()=>{
    await fsDisconnect();
  });

  if (fsAutosave) fsAutosave.addEventListener("change", ()=>{
    if (!state.fileSync) state.fileSync = { autosave: true, requireFile: false };
    state.fileSync.autosave = !!fsAutosave.checked;
    save();
  });

  if (fsRequireFile) fsRequireFile.addEventListener("change", ()=>{
    if (!state.fileSync) state.fileSync = { autosave: true, requireFile: false };
    state.fileSync.requireFile = !!fsRequireFile.checked;
    save();
    updateFsUI();
  });

  document.getElementById("btnExportSie4").addEventListener("click", ()=> exportSIE4(sieYearSelect.value));

  if (btnImportSie){
    btnImportSie.addEventListener("click", async ()=>{
      const file = sieImportFile && sieImportFile.files ? sieImportFile.files[0] : null;
      if (!file) return alert("Välj en SIE-fil först.");
      const enc = sieImportEncoding ? sieImportEncoding.value : "utf-8";
      const wipe = !!(sieImportWipe && sieImportWipe.checked);

      try {
        const txt = await readFileAsText(file, enc);
        const parsed = parseSIE(txt);
        const stats = mergeParsedSIE(parsed, wipe);
        alert(
          `Import klar.\n` +
          `År: ${stats.before.years} → ${stats.after.years}\n` +
          `Konton: ${stats.before.accounts} → ${stats.after.accounts}\n` +
          `Verifikationer: ${stats.before.vouchers} → ${stats.after.vouchers}`
        );
      } catch (e){
        console.error(e);
        alert("Kunde inte importera filen. Testa en annan teckenkodning (UTF-8 / Windows-1252 / IBM437)." );
      }

      if (sieImportFile) sieImportFile.value = "";
    });
  }
  document.getElementById("btnExportTrialCsv").addEventListener("click", ()=> exportTrialCsv(trialYearSelect.value));

  document.getElementById("btnSaveSettings").addEventListener("click", ()=>{
    state.company.name = sCompany.value.trim() || "Mini-bokföring";
    state.company.orgnr = sOrgnr.value.trim();
    state.company.currency = sCurrency.value;
    state.company.defaultSign = sSign.value.trim();
    save();
  });

  document.getElementById("btnAddYear").addEventListener("click", ()=>{
    const s = fyStart.value; const e = fyEnd.value;
    if (!s || !e) return alert("Ange start- och slutdatum.");
    const id = String(s.slice(0,4));
    if (state.fiscalYears.some(y=>y.id===id)) return alert("Året finns redan (id = första året i startdatum).");
    state.fiscalYears.push({ id, start:s, end:e });
    state.activeYearId = id;
    save();
  });

  document.getElementById("btnCarry").addEventListener("click", ()=>{
    if (!confirm("Skapa ingående balans i 'Till'-året baserat på saldon i 'Från'-året?")) return;
    carryForwardIB(carryFrom.value, carryTo.value);
  });

  document.getElementById("btnFillExample").addEventListener("click", ()=>{
    // Creates the four example vouchers A76-A79 on 2024-12-31
    const yearId = yearSelect.value || state.activeYearId;
    const y = getYear(yearId);
    if (!y) return;
    const date = `${yearId}-12-31`;

    const examples = [
      { no:"76", text:"Justering bank", lines:[ {acc:"1930", amt:+5676.65}, {acc:"2013", amt:-5676.65} ] },
      { no:"77", text:"Justering skattekonto", lines:[ {acc:"1630", amt:+965.00}, {acc:"2013", amt:-965.00} ] },
      { no:"78", text:"Justering lager", lines:[ {acc:"1460", amt:+29700.00}, {acc:"4960", amt:-29700.00} ] },
      { no:"79", text:"Årets resultat", lines:[ {acc:"8999", amt:+2310.60}, {acc:"2019", amt:-2310.60} ] },
    ];

    // Ensure accounts exist
    for (const ex of examples){
      for (const l of ex.lines){
        if (!state.accounts[l.acc]) state.accounts[l.acc] = { name: `(konto ${l.acc})`, type: guessTypeFromAccountNo(l.acc) };
      }
    }

    // Insert
    examples.forEach(ex => {
      state.vouchers.push({
        id: crypto.randomUUID(),
        yearId,
        series:"A",
        no: ex.no,
        date,
        text: ex.text,
        regDate: todayISO(),
        sign: state.company.defaultSign || "",
        lines: ex.lines.map(l => ({ account:l.acc, text:ex.text, amount:l.amt }))
      });
    });

    save();
    alert("La in A76–A79 som exempel (kontrollera beloppen innan du använder i skarp bokföring)." );
  });

  // Keep balance badge updated
  [vDate, vSeries, vNo, vText, vSign].forEach(el => el.addEventListener("input", updateBalanceBadge));

  // --- Render all ---
  function renderAll(){
    fillYearSelectors();
    renderVoucherList();
    renderLines();
    updateBalanceBadge();
    if (!document.getElementById("tab-reports").hidden) renderReports();
    if (!document.getElementById("tab-accounts").hidden) renderAccounts();
  }

  // --- Init ---
  fillYearSelectors();
  yearSelect.value = state.activeYearId;
  vDate.value = todayISO();
  newVoucher();
  renderAll();

  // Restore file handle (if previously connected)
  (async ()=>{
    try {
      const h = await idbGet("dataFileHandle");
      if (h){
        fsHandle = h;
      }
    } catch (e){
      // ignore
    }
    updateFsUI();
  })();

})();
</script>
</body>
</html>
